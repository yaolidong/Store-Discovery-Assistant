version: '3.8'
services:
  backend:
    build: ./backend
    ports:
      - "5000:5000"
    volumes:
      - ./backend:/app # Mount backend code for development
      # The travel_planner.db will be created inside /app in the container.
      # To persist it on the host, ensure the backend code writes it to /app/travel_planner.db
      # And this volume mount will effectively make it appear in ./backend/travel_planner.db on the host.
      # Alternatively, define a named volume for the database if it's preferred.
    environment:
      - FLASK_ENV=development # or production
      - FLASK_DEBUG=1 # Ensures debugger is active and reloader works

  frontend:
    build: ./frontend
    ports:
      - "8080:80" # Map host port 8080 to container port 80
    depends_on:
      - backend
    volumes:
      - ./frontend:/usr/share/nginx/html # Mount frontend code for development
      # The nginx.conf is copied during build, but if you want to live-reload nginx conf:
      # - ./frontend/nginx.conf:/etc/nginx/conf.d/default.conf

# It's good practice to ensure travel_planner.db is created if it doesn't exist,
# or to handle its path correctly in app.py.
# The current backend volume mount ./backend:/app should make travel_planner.db
# (if created by Flask in its default location relative to app.py)
# appear in the host's ./backend directory.
# No separate named volume is strictly needed if this behavior is acceptable.
# volumes:
#   travel_planner_db_data: # Example if a named volume was used for the DB
# In app.py, DATABASE_URI is 'sqlite:///travel_planner.db'. With WORKDIR /app,
# this means the db is at /app/travel_planner.db in the container.
# The volume mount - ./backend:/app means /app/travel_planner.db in container
# is ./backend/travel_planner.db on the host.
# The prompt's volume `- ./travel_planner.db:/app/travel_planner.db` is more explicit for the db file itself.
# Let's refine the backend volume to match the prompt's intention for the database file more directly.

# Re-adjusting backend volumes based on prompt to be more specific for the db file.
# However, mounting a single file that might not exist initially can be tricky with Docker.
# Docker might create a directory if the source file doesn't exist.
# It's often safer to mount the parent directory and ensure the app creates the file within that mounted dir.
# The current ./backend:/app already covers this if db is in /app.
# Let's stick to the prompt's specific volume for the DB for now and see.
# If travel_planner.db is in the root of the project, it would be:
# - ./travel_planner.db:/app/travel_planner.db
# But app.py puts it relative to itself, so it's in backend/travel_planner.db on host.
# So, the ./backend:/app mount is correct for that.
# The prompt's `./travel_planner.db:/app/travel_planner.db` implied the db is in project root.
# I will assume the db path in app.py ('sqlite:///travel_planner.db') means it's created
# inside the backend directory (which is /app in container).
# So the volume mount `./backend:/app` for the backend service is appropriate.
# The prompt's example for the db volume was: `- ./travel_planner.db:/app/travel_planner.db`
# This suggests the db file is in the project root on the host.
# Let's assume the app.py will create travel_planner.db in its current working dir (/app).
# So, if we want it in the project root on host:
# volumes:
#   - ./backend:/app # For code
#   - ./travel_planner.db:/app/travel_planner.db # For DB in project root
# If we want it in ./backend/travel_planner.db on host:
# volumes:
#   - ./backend:/app # This covers both code and DB if DB is in /app
# I will use the latter, simpler one.
# The prompt also listed `volumes: travel_planner_db:` at the end, implying a named volume.
# I'll remove the explicit file mount for the db for now and rely on the ./backend:/app mount,
# which is simpler and usually works fine for SQLite during development.
# If persistence outside the ./backend dir is needed, a named volume is better.
# For now, keeping it simple.
# Corrected backend volume to be just the code mount, as the db will reside within that mounted directory.
# The prompt had a `volumes:` section at the root level, and also a file-specific mount for the DB.
# This is a bit contradictory.
# Using `- ./backend:/app` means `travel_planner.db` (created in `/app` by Flask) will live in `./backend/travel_planner.db` on the host. This is fine.
# The root `volumes: travel_planner_db:` is only needed if you define a named volume and use it.
# I'll remove the root `volumes:` as I'm not using a named volume in the service definition.
# The prompt's example:
# volumes:
#   - ./backend:/app
#   - ./travel_planner.db:/app/travel_planner.db  <-- This line implies travel_planner.db is in project root on host
# This is fine if app.py is configured to put the DB there, but by default, 'sqlite:///travel_planner.db' with WORKDIR /app
# will put it in /app/travel_planner.db.
# I will keep the backend volume as just `./backend:/app` which correctly maps the db file if it's inside the backend dir.
# And I will remove the top-level `volumes:` key as no named volumes are being used.
# The prompt's example for `docker-compose.yml` had a root `volumes:` key and also a direct file mapping for the DB.
# This is slightly confusing. Let's assume the DB `travel_planner.db` is created by `app.py` inside the `backend` directory.
# In that case, the `volumes: - ./backend:/app` for the backend service is sufficient to persist the DB
# at `backend/travel_planner.db` on the host.
# I will remove the separate `./travel_planner.db:/app/travel_planner.db` line and the root `volumes:` key
# to avoid confusion, assuming the DB is within the backend directory.

services:
  backend:
    build: ./backend
    ports:
      - "5000:5000"
    volumes:
      - ./backend:/app # Mounts the backend directory, including travel_planner.db if created there
    environment:
      - FLASK_ENV=development
      - FLASK_DEBUG=1

  frontend:
    build: ./frontend
    ports:
      - "8080:80"
    depends_on:
      - backend
    volumes:
      - ./frontend:/usr/share/nginx/html # For live updates of frontend static files
      # - ./frontend/nginx.conf:/etc/nginx/conf.d/default.conf # For live Nginx config updates (optional)

# No root-level 'volumes:' key needed unless using named volumes.
# The travel_planner.db is expected to be at ./backend/travel_planner.db on the host
# because app.py's SQLALCHEMY_DATABASE_URI is 'sqlite:///travel_planner.db' and WORKDIR is /app.
# The volume mount ./backend:/app maps /app (container) to ./backend (host).
```
